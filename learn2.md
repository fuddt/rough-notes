# 設計思考トレーニング
## 〜 初代バイオハザードのアイテム管理システムをゼロから考える 〜

> **この資料の目的**
> 完成されたコードを読んで「なるほど」で終わらせないために。
> 「なぜこうなったのか」——問いを立て、整理し、小さく試す——
> その思考のプロセスそのものを体験することがゴールだ。

---

## はじめに：なぜ「0から1」が難しいのか

コードが書けるエンジニアでも、白紙から設計を始めるときに手が止まる。
原因はほぼ1つだ。

> **「何を作るか」が定まる前に「どう作るか」を考えようとする**

これは認知の順番が逆になっている。
正しい順番はこうだ。

```
① 何が起きているのかを観察する（仕様を読む）
② 何を扱うのかを整理する（データを列挙する）
③ 操作の種類を整理する（振る舞いを列挙する）
④ 最小単位で試す（動くものを作る）
⑤ 問題を見つけたら設計を育てる（リファクタリング）
```

この資料はこの順番に沿って進む。

---

## STEP 1：観察する——「何が起きているのか」を言語化する

設計を始める前にやるべきことは、コードを書くことではない。
**対象のシステムを観察して、言葉で説明できるようにすること**だ。

### 演習 1-1：初代バイオハザードのアイテム操作を思い出す

実際にゲームをプレイしたことがある人は記憶を頼りに、なければ仕様として与えられた情報を使い、以下の問いに自分の言葉で答えてみてほしい。

```
Q1. プレイヤーはアイテムをどこに持てるか？何個まで？
Q2. アイテムBOXはマップのどこにある？全部のBOXの中身は同じか？
Q3. アイテムには何か種類があるか？その種類ごとに何か違うか？
Q4. アイテムに対してできる操作は何か？（動詞で列挙せよ）
Q5. できない操作はあるか？（例：捨てられないアイテム）
```

> **ポイント**
> この段階でコードのことは考えなくていい。
> 「誰が・何を・どうする」を日本語で書けることが先決だ。

---

### 参考：観察の結果として出てくるはずの言語化

上の問いに向き合うと、だいたい以下の内容が出てくるはずだ。

| 観察した事実 | 注目すべき点 |
|---|---|
| インベントリは8スロット固定 | 「固定サイズのコンテナ」が必要 |
| BOXはどこでも同じ中身を共有する | インスタンスが「1つだけ」でないといけない |
| アイテムには武器・弾薬・ハーブ・鍵などがある | 「種類の違い」を表現する手段が必要 |
| 使う・調べる・捨てる・結合するができる | アイテムに対して「操作」が存在する |
| 鍵アイテムは捨てられない | 同じ「アイテム」でも振る舞いが違う場合がある |
| ハーブは組み合わせると効果が変わる | 「結合ルール」が存在する |

この表が書けたら STEP 1 は完了だ。

---

## STEP 2：データを整理する——「何を扱うのか」を構造化する

言語化が終わったら、次は**データの輪郭を描く**作業に入る。

### 演習 2-1：アイテムの共通点と差異を整理する

下の表を自分で埋めてみてほしい。

| アイテム種別 | 名前 | 使える？ | 捨てられる？ | 結合できる？ | 固有のデータは何か？ |
|---|---|---|---|---|---|
| 武器 | ハンドガン | ○ | ○ | ○（弾薬と） | ??? |
| 弾薬 | ハンドガン弾 | △ | ○ | ○（武器と） | ??? |
| ハーブ | 緑ハーブ | ○ | ○ | ○（他ハーブと） | ??? |
| 鍵 | 洋館の鍵 | ○ | **×** | × | ??? |

> **問い：「固有のデータ」の欄に何を書くべきか？**
> 武器なら「弾数」「マガジンサイズ」「対応弾薬の種類」などが候補になる。
> 自分で考えてから先に進んでほしい。

---

### STEP 2 の整理から見えてくる設計上の判断

この整理をすると、自然に以下の問いが生まれる。

**問い A**
> 全アイテムに共通の性質（名前・使える・捨てられる）と、
> 種別ごとの固有データがある。
> これをどうコードで表現するか？

**問い B**
> 「使える」「捨てられる」という振る舞いは全種別にあるが、
> 中身が種別によって違う。
> どう設計すれば追加・変更がしやすいか？

ここで初めて「継承か、コンポジションか」「仮想関数か」という技術的な話が意味を持ち始める。

問いが生まれる前に設計パターンの名前を持ち出すのは、答えを先に言っているのと同じだ。

---

## STEP 3：操作を整理する——「何ができるのか」を動詞で列挙する

データの次は**操作（振る舞い）**の整理だ。

### 演習 3-1：操作の一覧を「誰が・何に・何をするか」で書く

```
例：
  プレイヤー が インベントリ に アイテムを追加する
  プレイヤー が インベントリ の アイテムを使う
  プレイヤー が インベントリ の アイテムを捨てる
  プレイヤー が インベントリ と BOX の間でアイテムを移動する
  プレイヤー が 2つのアイテム を 結合する
```

自分でリストを作ってみてほしい。

---

### 操作を整理したあとに見えてくる問い

**問い C**
> 「2つのアイテムを結合する」というとき、
> どちらが「主体」でどちらが「対象」か？
> それとも対等か？

**問い D**
> ハーブ同士の結合と、弾薬を武器に装填する操作は、
> 見た目は似ているが中身は全然違う。
> 「結合」という1つの操作に複数のルールをどう持たせるか？

**問い E**
> BOXからアイテムを取り出すとき、
> インベントリが満杯だったらどうするか？
> この「制約チェック」はどこに書くべきか？

これらの問いに答えようとしたとき、自然と設計の形が決まっていく。

---

## STEP 4：最小単位で試す——「まず動くものを作る」

ここからやっとコードの話になる。
しかし最初から全部を作ろうとしてはいけない。

### 原則：最初に作るべきは「最も核心に近い最小のもの」

このシステムで最も核心にあるものは何か？

**「アイテム」そのものだ。**

BOXもインベントリもUIも、アイテムがなければ始まらない。
だからまず「アイテムの最小定義」から始める。

---

### 最小実装 v1：まず1種類のアイテムだけ作る

設計パターンも継承も使わない。まず動けばいい。

```cpp
// ----------------------------------------------------------
// 最初の一歩: アイテムを「とにかく表現する」だけ
// 種別も継承も何もない。名前と説明があればアイテムと呼ぶ
// ----------------------------------------------------------

#include <iostream>
#include <string>

struct Item {
    std::string name;
    std::string description;
};

int main() {
    Item handgun;
    handgun.name = "ハンドガン";
    handgun.description = "基本的な護身用拳銃";

    std::cout << handgun.name << ": " << handgun.description << "\n";
    return 0;
}
```

> **この時点で問うべきこと**
> - これで「アイテムを表現できた」と言えるか？
> - 何が足りないか？
> - 次に何を追加すべきか？

---

### 問いから次の実装へ

「足りないもの」として出てくるのは、たとえばこういうことだ。

- 武器は「弾数」を持つが、ハーブは持たない。同じ `struct` では無理だ
- 「使う」という操作の中身が種別によって違う
- 「捨てられるかどうか」が種別によって決まっている

この問いに答えようとして初めて、**継承と仮想関数の必要性**が自分の問題として立ち現れる。

---

### 最小実装 v2：「種別の違い」を継承で表現してみる

```cpp
// ----------------------------------------------------------
// v2: 「使う」操作が種別によって違う、を表現したい
// そのために基底クラスと派生クラスを導入する
//
// 注意: この時点ではまだシンプルに保つ
//       unique_ptr も STL コンテナも使わなくていい
// ----------------------------------------------------------

#include <iostream>
#include <string>

// 基底クラス: 全アイテムに共通する性質だけ持つ
class Item {
public:
    Item(std::string name) : name_(std::move(name)) {}
    virtual ~Item() = default;

    // 「使う」操作: 種別によって中身が違うので virtual にする
    virtual void use() = 0;

    // 「捨てられるか」: デフォルトは true、鍵アイテムだけ override する
    virtual bool canDiscard() const { return true; }

    const std::string& getName() const { return name_; }

protected:
    std::string name_;
};

// 派生クラス: ハーブ
class Herb : public Item {
public:
    Herb() : Item("緑ハーブ") {}

    void use() override {
        std::cout << name_ << "を使った: HPが少し回復した\n";
    }
};

// 派生クラス: 鍵アイテム
class KeyItem : public Item {
public:
    KeyItem(std::string name) : Item(std::move(name)) {}

    void use() override {
        std::cout << name_ << "を調べた: 重要なアイテムだ\n";
    }

    // 鍵アイテムは捨てられない: override で false を返す
    bool canDiscard() const override { return false; }
};

int main() {
    Herb herb;
    KeyItem key("洋館の鍵");

    herb.use();
    key.use();

    std::cout << herb.getName() << " は捨てられる?: "
              << (herb.canDiscard() ? "はい" : "いいえ") << "\n";
    std::cout << key.getName() << " は捨てられる?: "
              << (key.canDiscard() ? "はい" : "いいえ") << "\n";

    return 0;
}
```

> **v2 で確認できたこと**
> - 種別ごとの違いを継承で表現できた
> - `canDiscard()` のデフォルト動作を基底クラスに持たせ、
>   例外だけ override する、という構造が使えた
>
> **v2 で次に問うべきこと**
> - 複数のアイテムをまとめて管理したい。どうするか？
> - 生ポインタで扱うのは危険だ。何を使うべきか？

---

### 最小実装 v3：スロット管理を「とにかく動く形」で作る

```cpp
// ----------------------------------------------------------
// v3: アイテムを複数管理するためのコンテナを作る
//
// ここで unique_ptr を導入する理由:
//   生ポインタで派生クラスを扱うと所有権が曖昧になり、
//   delete 忘れや二重 delete が起きる
//   unique_ptr を使えば「このポインタが所有者」が明確になる
// ----------------------------------------------------------

#include <iostream>
#include <string>
#include <array>
#include <memory>
#include <optional>

// ---- 前回のItem, Herb, KeyItem の定義はここにある想定 ----

// 4スロットの簡易インベントリ（まず4で試す。8は後で変える）
class SimpleInventory {
public:
    // optional<unique_ptr<Item>>: 空スロットは nullopt で表現する
    using Slot = std::optional<std::unique_ptr<Item>>;

    SimpleInventory() { slots_.fill(std::nullopt); }

    // 空きスロットにアイテムを追加する
    bool add(std::unique_ptr<Item> item) {
        for (auto& slot : slots_) {
            if (!slot.has_value()) {
                slot = std::move(item);
                return true;
            }
        }
        return false; // 満杯
    }

    // 全スロットを表示する
    void display() const {
        std::cout << "\n--- インベントリ ---\n";
        for (std::size_t i = 0; i < slots_.size(); ++i) {
            std::cout << "[" << i << "] ";
            if (slots_[i].has_value()) {
                std::cout << slots_[i]->get()->getName();
            } else {
                std::cout << "空";
            }
            std::cout << "\n";
        }
    }

private:
    std::array<Slot, 4> slots_; // まず4で動かしてみる
};

int main() {
    SimpleInventory inv;

    inv.add(std::make_unique<Herb>());
    inv.add(std::make_unique<KeyItem>("洋館の鍵"));

    inv.display();
    return 0;
}
```

> **v3 で確認できたこと**
> - `unique_ptr` + `optional` の組み合わせで「空スロット」が表現できた
> - `array<Slot, 4>` でスロット数が固定できた
>
> **v3 で次に問うべきこと**
> - スロット数を変えたくなったとき、毎回コードを書き直すのか？
> - BOX は「全BOXが同じ中身を共有する」という制約がある。
>   どうすれば「インスタンスが1つだけ」を保証できるか？

---

## STEP 5：問いから設計へ——問いが答えを引き寄せる

STEP 4 の問いに向き合うと、設計パターンが「解決策」として登場する。
パターンの名前を先に覚えるのではなく、**問いが先、パターンが後**だ。

| 問い | 問いへの回答として自然に出てくる設計 |
|---|---|
| スロット数を外から変えられないか？ | `template <std::size_t N>` でパラメータ化する |
| インスタンスを1つだけにしたい | Singleton パターン |
| 結合ルールを種類ごとに切り替えたい | Strategy パターン |
| アイテム生成を1か所に集めたい | Factory パターン |
| 全アイテムに共通の操作フローを持たせたい | Template Method パターン |

---

### 演習 5-1：スロット数の問い——テンプレートを使う理由を自分で考える

v3 では `array<Slot, 4>` と書いた。
もし「初代は8スロット、バイオ2では10スロット」に対応したくなったら何をするか？

選択肢を考えてみてほしい。

```
選択肢 A: コードを書き直す → 保守性が低い、NG
選択肢 B: コンストラクタで数を受け取り、vector を使う
           → サイズが実行時まで不定、スタックに置けない
選択肢 C: テンプレートの非型引数でコンパイル時にサイズを決める
           → コンパイル時に確定、array のまま使える
```

C が最も適切だ。この結論に自分で辿り着けることが重要だ。

```cpp
// template <std::size_t SlotCount> にするだけで
// using Inventory = InventoryBase<8>;  ← 初代
// using Inventory = InventoryBase<10>; ← バイオ2
// のように使い分けられる
template <std::size_t SlotCount = 8>
class InventoryBase {
    // ...
};
```

---

### 演習 5-2：BOXの問い——Singletonが必要な理由を自分で考える

「全BOXが同じ中身を共有する」という仕様がある。
もし `ItemBox box;` と各部屋で別々のインスタンスを作ったらどうなるか？

```
部屋A の box と 部屋B の box は別物になる
→ 部屋Aで預けたアイテムが部屋Bで見えない
→ 仕様違反
```

この問題を解決するには「インスタンスが1つだけ」を言語レベルで強制する必要がある。
それが Singleton パターンの存在理由だ。

```cpp
// コンストラクタを private にすれば外部からの生成を防げる
// static メンバ関数で唯一のインスタンスを返す
class ItemBox {
public:
    static ItemBox& getInstance() {
        static ItemBox instance; // C++11以降、これはスレッドセーフ
        return instance;
    }
private:
    ItemBox() = default; // 外から作れない
};
```

---

### 演習 5-3：結合の問い——Strategy が必要な理由を自分で考える

「ハーブ同士の結合」と「弾薬を武器に装填する」は、見た目は同じ「2つを組み合わせる」操作だが、中身のロジックは完全に別物だ。

もし `ItemCombiner` の中に全ルールを `if-else` で書いたらどうなるか？

```cpp
// 悪い例: ルールが増えるたびにこのクラスを変更しなければならない
void combine(Item& a, Item& b) {
    if (a はハーブ && b はハーブ) { ... }
    else if (a は武器 && b は弾薬) { ... }
    else if (...) { ... } // どんどん増える
}
```

これは Open/Closed 原則（拡張には開いていて、修正には閉じている）に違反している。

Strategy パターンを使えば、新しい結合ルールを追加するときに `ItemCombiner` 本体を変更せず、新しいクラスを追加するだけで済む。

---

## STEP 6：全体を振り返る——思考の順番をまとめる

```
① 観察する       「何が起きているか」を言葉で説明できるようにする
        ↓
② データを整理   「何を扱うか」を表にする（共通点・差異を分ける）
        ↓
③ 操作を整理     「誰が・何に・何をするか」を動詞で列挙する
        ↓
④ 最小単位で試す  struct → class → 継承 → コンテナ の順に小さく積む
        ↓
⑤ 問いを立てる   動かしてみて「何が足りないか」「何が壊れるか」を問う
        ↓
⑥ 設計へ         問いへの回答として設計パターンが自然に出てくる
        ↓
⑦ 育てる         問いと実装を繰り返しながらコードを育てていく
```

---

## 最後に：この資料で伝えたかったこと

上級のエンジニアでも「0から1」が難しいのは、能力の問題ではなく**手順の問題**だ。

完成したコードを見て「なるほど」と思うのは、答えを見てから問題を解くのと同じだ。
本当の力は「問いを立てる力」にある。

> - 観察が足りないと、問いが立てられない
> - 問いが立てられないと、設計の選択に理由が持てない
> - 理由のない設計は、変更に弱く、説明できない

コードを書く前に「これは何を解決するのか」を言えること。
それがこのトレーニングで身につけてほしいことだ。

---

*付録として完成版コードの設計レポートを別資料として配布する。
本資料を読んだあとに参照することで、設計の意図が読み取れるはずだ。*
